<!DOCTYPE html> 
<html lang="en"> 
<head> 
	<meta charset="utf-8" /> 
	<title>gyro.js - easy access to your web browsers built in accelerometer's and gyroscope's</title>
	<style>
		html, body { margin: 0; padding: 0;}
		canvas { border: 1px solid black;}
	</style>
</head>
<body>
	<canvas id="c"></canvas>
	<canvas id="jc"></canvas>
	<p>gyro.getFeatures: <span id="features"></span></p>
	<span id="example"></span>
	<script src="//ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.js"></script>
	<!--<script src="../js/fabric.min.js"></script>-->
	<script src="../../demo5/js/utils.js"></script>
	<script src="../../demo5/js/accelerometer.js"></script>
	<!--<script src="../js/gyro.js"></script>-->
	<script>

	var clamp = function (a,b,c)  {
		return Math.max(b,Math.min(c,a));
	};

	var midPointBtwn = function (p1, p2) {
 		return {
		    x: p1.x + (p2.x - p1.x) / 2,
		    y: p1.y + (p2.y - p1.y) / 2
		};
	};

	var increment = function (v3, x, y, z) {
		v3[0] += x;
		v3[1] += y;
		v3[2] += z;
		return v3;
	}

	var toTwoDecimalPlaces = function(v3) {
		v3[0] = +v3[0].toFixed(2);
		v3[1] = +v3[1].toFixed(2);
		v3[2] = +v3[2].toFixed(2);
	}

	var getSign = function(n) {
		return n >= 0;
	}

	$(function(){
		var before = new Date().getTime(),
			now,
			dt,
			shakeyMinThreshold = 15,
			sideToSideMaxThreshold = 10,
			sideToSideMinThreshold = 5,

			data,
			sampleData,
			sampleCount = 0,
			_bufferLength = 1024,
			_w,
			_h,
			samplingPeriod = 3000,	// ms we spend listening, before restarting 
			waitPeriod = 7000,
			// start = data.t[0],
			start,
			curCol = 0,
			_c = document.getElementById('c'),
			_ctx = _c.getContext('2d'),
			_jerkC = document.getElementById('jc'),
			_jCtx = _jerkC.getContext('2d'),
			_bgGrd,
			sliceWidth,
			sliceHeight,
			_grd,
			interval,
			energy,
			stress,
			lastCrossingX = 1,
			lastCrossingY = 1,
			lastCrossingZ = 1,
			moodMatrix = [
				'INDIFFERENT', 'TRANQUIL', 'RELAXED', 'JOYFUL',
				'PEACEFUL', 'JUBILANT', 'CAREFREE', 'SILLY',
				'CONFIDENT', 'OPTIMISTIC', 'CALM', 'CRFEATIVE',
				'REFRESHED', 'INVIGORATED', 'ENERGIZED', 'ANXIOUS',
				'EXHILARATED', 'INSPIDER', 'WILD', 'WORRIED'
			],
			moodColors = [
				'#74637F', '#00AD9C', '#FFB380', '#006142',
				'#B6C1FF', '#F6A800', '#FF6559', '#FFD94F',
				'#D11E15', '#D03362', '#B78FC1', '#FF00B1',
				'#5BC2EF', '#005FB9', '#FF5500', '#7A2E36',
				'#C5002E', '#39835D', '#6E328A', '#626B99'
			];
 		
 		_w = window.innerWidth;
 		_h = _w;
 		sliceWidth = _w / samplingPeriod;
 		sliceHeight = _h / samplingPeriod;

		// jerk = da / dt
		// velocity = initial velocity + acceleration * dt
		// displacement = initial displacement + current velocity * dt

		// gyro.init();
		accelerometer.start();

		_c.width = _w;
		_c.height = _h;
		_jerkC.width = _w;
		_jerkC.height = _h / 3;


		_bgGrd = _ctx.createLinearGradient(_w / 2, 0, _w / 2, _h);

		_bgGrd.addColorStop(0, 'white');
		_bgGrd.addColorStop(1, '#FDF8FF');


		_grd = _ctx.createLinearGradient(0, _h / 2, _w, _h / 2);
		_grd.addColorStop(0,"#FB9CE7");
		_grd.addColorStop(0.25,"#05158F");
		_grd.addColorStop(0.5, "#4391CD");
		_grd.addColorStop(0.75, "#5FF0FD");
		_grd.addColorStop(1, "#BDF5FD");

		_grdVert = _ctx.createLinearGradient(0, _h, _w/2, 0);
		_grdVert.addColorStop(0,"#FB9CE7");
		_grdVert.addColorStop(0.25,"#05158F");
		_grdVert.addColorStop(0.5, "#4391CD");
		_grdVert.addColorStop(0.75, "#5FF0FD");
		_grdVert.addColorStop(1, "#BDF5FD");


		_jCtx.fillStyle = _ctx.fillStyle = _bgGrd;
		_ctx.fillRect(0,0,_w,_h);
		_jCtx.fillRect(0,0,_w,_h/3);
		_jCtx.strokeStyle = _grd; 

		_jCtx.lineJoin = _ctx.lineJoin = 'butt';
		_jCtx.lineCap = _ctx.lineCap = 'round';
		var count = 0;
		start = new Date().getTime();
		
		interval = setInterval(function(){

			sampleData = accelerometer.readData();
			
			now = sampleData.t;
			dt = (now - before) / 1000;
			


			_ctx.lineWidth = Math.max(6 + sampleData.acceleration.z * 2, 1);
			_ctx.strokeStyle = _grd;
	        _ctx.beginPath();

	        // plot vertical acceleration:
	        var x1 = Math.floor(sliceWidth * (before - start));
	        var y1 = Math.floor(clamp((_h - ((data) ? data.acceleration.y : 0) * -20) / 2, 2, _h - 2));
	        var x2 = Math.floor(sliceWidth * (now - start));
	        var y2 = Math.floor(clamp((_h - sampleData.acceleration.y * -20) / 2, 2, _h-2));

	        _ctx.moveTo(x1, y1);
			var midPoint = midPointBtwn({x:x1, y:y1}, {x:x2,y:y2});

	        // _ctx.lineTo(x2, y2);
	        _ctx.quadraticCurveTo(x1, y1, midPoint.x, midPoint.y);
	        _ctx.quadraticCurveTo(midPoint.x, midPoint.y, x2, y2);
			_ctx.stroke();

			// plot horizontal accelaration:
			_ctx.strokeStyle = _grdVert;
	        _ctx.beginPath();
	        x1 = Math.floor(clamp((_w - ((data) ? data.acceleration.x : 0) * -20) / 2, 2, _w - 2));
	        y1 = _h - Math.floor(sliceHeight * (before - start));
	        x2 = Math.floor(clamp((_w - sampleData.acceleration.x * -20) / 2, 2, _w-2));
	        y2 = _h - Math.floor(sliceHeight * (now - start));

	        _ctx.moveTo(x1, y1);
			var midPoint = midPointBtwn({x:x1, y:y1}, {x:x2,y:y2});

	        // _ctx.lineTo(x2, y2);
	        _ctx.quadraticCurveTo(x1, y1, midPoint.x, midPoint.y);
	        _ctx.quadraticCurveTo(midPoint.x, midPoint.y, x2, y2);
			_ctx.stroke();

			var lastEnergy = Math.abs(sampleData.total.acceleration.x) + Math.abs(sampleData.total.acceleration.y) + Math.abs(sampleData.total.acceleration.z);

			
			before = now;

	        // min/max:
	        // loop around the canvas when we reach the end
			sampleCount++;


	        
	        if(now - start > samplingPeriod) {
	        	accelerometer.stop();
	        	// determine mood:
	        	var energy = (Math.abs(sampleData.avg.acceleration.x) + Math.abs(sampleData.avg.acceleration.y) + Math.abs(sampleData.avg.acceleration.z)) / 3;
	        	var stress = (Math.abs(sampleData.avg.jerk.x) + Math.abs(sampleData.avg.jerk.y) + Math.abs(sampleData.avg.jerk.z)) / 3;
	        	clearInterval(interval);

				var resultStr = 'energy= ' + (+energy).toFixed(2) + ' stress= ' +(+stress).toFixed(2)+'\n';
	        	if ( energy < 1 ) {
	        		energy = 0;	// 'calm'
	        	} else if ( energy < 3 ) {
	        		energy = 1;	// 'low'
	        	} else if ( energy < 6 ) {
	        		energy = 2;	// 'moderate'
	        	} else if ( energy < 9 ) {
	        		energy = 3; // 'hard'
	        	} else {
	        		energy = 4;	// 'very hard'
	        	}

	        	if ( stress < 10 ) {
	        		stress = 0;	// 'low'
	        	} else if ( stress < 120 ) {
	        		stress = 1;	// 'moderate'
	        	} else if ( stress < 300 ) {
	        		stress = 2;	// 'high'
	        	} else {
	        		stress = 3;	// 'very high'
	        	}


	        	var moodIndex = energy * 5 + stress;
	        	_ctx.textAlign = 'center';
	        	_ctx.font = '120px Tahoma';
	       		_ctx.strokeStyle = _bgGrd;
	       		_ctx.strokeWidth = 2;
	       		_ctx.strokeText(moodMatrix[moodIndex], _w / 2, _h / 2);
	        	_ctx.fillStyle = moodColors[moodIndex];
	       		_ctx.fillText(moodMatrix[moodIndex], _w / 2, _h / 2);

	   //      	plotJerk();

	        	resultStr += 'energy= ' + energy + '; stress= '+stress;
	        	var b = document.getElementById('example');
	        	b.innerHTML = resultStr;

	        }

			var b = document.getElementById('example'),
				f = document.getElementById('features');
			// f.innerHTML = gyro.getFeatures();

			data = $.extend(true, {}, sampleData);
			utils.printify(data);
			b.innerHTML = 
                "<p> j avg = (" + data.avg.jerk.x + ', ' + data.avg.jerk.y + ', ' + data.avg.jerk.z + ')</p>' +
                "<p> j max = (" + data.max.jerk.x + ', ' + data.max.jerk.y + ', ' + data.max.jerk.z + ')</p>' +
                "<p> j min = (" + data.min.jerk.x + ', ' + data.min.jerk.y + ', ' + data.min.jerk.z + ')</p>' +
                "<p> d = (" + data.total.displacement.x + ', ' + data.total.displacement.y + ', ' + data.total.displacement.z + ')</p>' +
                "<p> v avg = (" + data.avg.velocity.x + ', ' + data.avg.velocity.y + ', ' + data.avg.velocity.z + ')</p>' +
                "<p> a avg = (" + data.avg.acceleration.x + ', ' + data.avg.acceleration.y + ', ' + data.avg.acceleration.z + ')</p>' +
                "<p> a max = (" + data.max.acceleration.x + ', ' + data.max.acceleration.y + ', ' + data.max.acceleration.z + ')</p><br>' +
                "<p> a min = (" + data.min.acceleration.x + ', ' + data.min.acceleration.y + ', ' + data.min.acceleration.z + ')</p><br>' +
                "<p> dt = " + dt + "s </p><br>" + 
                "<p> ax = " + sampleData.acceleration.x + " m/s^2</p>" +
                "<p> vx = " + sampleData.velocity.x + "</p>" +
                "<p> dx = " + sampleData.displacement.x + "</p>" +
                "<p> jx = " + sampleData.jerk.x + "</p>" +
                "<br><p> ay = " + sampleData.acceleration.y + " m/s^2</p>" +
                "<p> vy = " + sampleData.velocity.y + "</p>" +
                "<p> dy = " + sampleData.displacement.y + "</p>" +
                "<p> jy = " + sampleData.jerk.y + "</p>" +
                "<br><p> az = " + sampleData.acceleration.z + " m/s^2</p>" +
                "<p> vz = " + sampleData.velocity.z + "</p>" +
                "<p> dz = " + sampleData.displacement.z + "</p>" +
                "<p> jz = " + sampleData.jerk.z + "</p>";
		}, 10);

		function plotJerk () {
			if (!isShakey(data.zeroCrossings)) {
				if (isSideToSide(data.zeroCrossings)) {
					console.log('side-to-side');
				} else {
					console.log('smooth');
				}
			} else {
				console.log('shakey');
			}

			_jCtx.beginPath();
			_jCtx.moveTo(0, _h / 6);

			for ( var i = 1; i < sampleCount; i++ ) {
				var jerkNow = data.jx[i] + data.jy[i] + data.jz[i];
				var jerkBefore = data.jx[i-1] + data.jy[i-1] + data.jz[i-1];
				
				var before = data.t[i - 1];
				var now = data.t[i];
		        var x1 = Math.floor(sliceWidth * (before - start));
		        var y1 = Math.floor(clamp((_h/3 - jerkBefore) / 2, 2, _h/3- 2));
		        var x2 = Math.floor(sliceWidth * (now - start));
		        var y2 = Math.floor(clamp((_h/3 - jerkNow * -20) / 2, 2, _h/3-2));

		        var midPoint = midPointBtwn({x:x1, y:y1}, {x:x2,y:y2});

		        _jCtx.quadraticCurveTo(x1, y1, midPoint.x, midPoint.y);
		        _jCtx.quadraticCurveTo(midPoint.x, midPoint.y, x2, y2);
			}
			_jCtx.stroke();
		};


		// function plotAverageAcceleration() {
		// 	_aCtx.beginPath();
		// 	_aCtx.moveTo(0, _h / 6);
		// 	var accSum = data.ax[0];
		// 	for ( var i = 1; i < sampleCount; i++ ) {
		// 		var accNow = data.ax[i] + data.ay[i] + data.az[i];
		// 		accSum += accNow;

				
				
		// 		var before = data.t[i - 1];
		// 		var now = data.t[i];
		//         var x1 = Math.floor(sliceWidth * (before - start));
		//         var y1 = Math.floor(clamp((_h/3 - accBefore) / 2, 2, _h/3- 2));
		//         var x2 = Math.floor(sliceWidth * (now - start));
		//         var y2 = Math.floor(clamp((_h/3 - accNow * -20) / 2, 2, _h/3-2));

		//         var midPoint = midPointBtwn({x:x1, y:y1}, {x:x2,y:y2});

		//         _aCtx.quadraticCurveTo(x1, y1, midPoint.x, midPoint.y);
		//         _aCtx.quadraticCurveTo(midPoint.x, midPoint.y, x2, y2);
		// 	}
		// 	_aCtx.stroke();
		// }

		// takes in an array vector of zero crossings:
		// var isShakey = function (zeroCrossings) {
		// 	console.log(zeroCrossings);
		// 	var count = (zeroCrossings[0] > shakeyMinThreshold) + 
		// 		(zeroCrossings[1] > shakeyMinThreshold) + 
		// 		(zeroCrossings[2] > shakeyMinThreshold);
		// 	return count > 1;
		// }

		// var isSideToSide = function (zeroCrossings) {
		// 	var enoughInX = zeroCrossings[0] < sideToSideMaxThreshold && zeroCrossings[0] > sideToSideMinThreshold;
		// 	return enoughInX && zeroCrossings[1] < sideToSideMaxThreshold / 2 && zeroCrossings[2] < sideToSideMaxThreshold / 2; 
		// } 
	});
	</script>
</body>
</html>
